import React from "react";
import { connect } from "react-redux";
import { initBricks, moveBrick } from "../actions";
import { getBricks } from "../selectors";
import Brick from "../Brick";
import Confetti from "react-confetti";
import { CSSTransition } from "react-transition-group";
import '../App.css';
import './monokai.css';
import './BrickGame.css';
import Gist from "react-gist";



function BrickGame({bricks = [], onInitBricks, onMoveBrick}) {
  const gameSize = 4;
  
  //let codeString = '';

  const [codeString, setCodeString] = React.useState("");

  React.useEffect(async ()  =>  {
    onInitBricks(allNewBricks());
    

    await fetch('./BrickGame.js').then(r=>r.text()).then(text => setCodeString(text));

    console.log("LOGGING",codeString);
  }, []);

  function isWon() {
    let isWon = true;
    for (let i = 0; i < bricks.length - 1; i++) {
      isWon = isWon && bricks[i].value === i + 1;
    }
    return isWon;
  }

  // Can create non-solvable shuffle, better way is to manually shuffle the positions (or mathematically verify solvable shuffle)
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function allNewBricks() {
    const newBricks = [];
    const shuffledBricks = shuffleArray([...Array(gameSize * gameSize).keys()]);

    for (let i = 0; i < gameSize * gameSize; i++) {
      newBricks.push({
        id: i,
        value: shuffledBricks[i],
        // x-position 0-3, y-position 0-3
        xPos: i % gameSize,
        yPos: Math.floor(i / gameSize),
        animationClass: "",
      });
    }
    return newBricks;
  }

  const brickElements = bricks.length > 0 ? bricks.map((brick) => {
    return (
      <CSSTransition
        key={brick.id}
        in={bricks[brick.id].value > 0}
        timeout={300}
        classNames={brick.animationClass}
      >
        <Brick value={brick.value} moveBrick={() => onMoveBrick(brick.id)} />
      </CSSTransition>
    );
  }) : null;

  const style = {
    gridTemplate: `auto auto / repeat(${gameSize}, 1fr)`,
  };
  
  
  return (
    <>
    <div className="main">
      {isWon() && <Confetti />}
      <h1 className="title">15 Game</h1>
      <p className="instructions">
        Click on brick next to empty square to move. When 1-15 is aligned from
        top left to bottom right you have won.
      </p>
      <div className="brick-container" style={style}>{brickElements}</div>
      <button
        className="shuffle-bricks"
        onClick={() => {
          onInitBricks(allNewBricks());
        }}
      >
        Shuffle
      </button>
    </div>
    
    <Gist id="a99cc2e101679c9f6bda69ee3acfbb2d" />
    
    </>
  );
}

const mapStateToProps = state => ({
  bricks: getBricks(state),
});

const mapDispatchToProps = dispatch => ({
  onInitBricks: bricks => dispatch(initBricks(bricks)),
  onMoveBrick: id => dispatch(moveBrick(id)),
});

export default connect(mapStateToProps, mapDispatchToProps)(BrickGame);
